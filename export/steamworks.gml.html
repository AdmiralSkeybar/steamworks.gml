<html><head>
<meta charset="UTF-8">
<title>steamworks.gml cheat sheet</title>
<meta name="viewport" content="width=device-width" />
<meta name="livenode" content="#doc" />
<meta property="theme-color" content="#FFF037" />
<meta property="og:type" content="article" />
<meta property="og:locale" content="en_us" />
<meta property="og:site_name" content="YellowAfterlife" />
<meta property="og:title" content="steamworks.gml cheat sheet" />
<script type="text/javascript">
if (document.location.host == "yal.cc" && location.protocol == "http:") {
	document.location.protocol = "https:";
}
</script>
<style type="text/css">
body, #doc tt {
	font: 15px 'Open Sans', sans-serif;
	line-height: 1.35;
}
body {
	margin: 0;
}
.main {
	width: 100%;
	min-height: 100%;
	min-height: 100vh;
	background-color: #f9f9f9;
}
.page {
	max-width: 656px;
	background: #ffffff;
	margin: 0 auto;
	padding: 8px;
	box-shadow: 0 0 0 2px #eee;
	min-height: 100%;
	min-height: 100vh;
	box-sizing: border-box;
}
.page > p:first-child {
	margin-top: 0;
}

#doc, #doc ul, #doc ol {
	padding-left: 0;
	margin: 0;
}
#doc div ul, #doc div ol {
	padding-left: 20px;
}
#doc div ul li {
	list-style: disc;
	list-style-image: url('data:image/svg+xml;base256,<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="1em" viewBox="0 0 20px 1em"><circle cx="17px" cy="0.675em" r="2px"/></svg>'); 
}

#doc .header {
	display: block;
	outline: none;
	text-decoration: none;
	margin: 0;
	font-weight: 700;
	font-size: 100%;
	color: #458;
	border-left: 2px solid #f3f3f3;/* #f9f9f9*/
	padding-left: 4px;
	padding-top: 1px;
	padding-bottom: 1px;
	cursor: pointer;
}
#doc .header::before {
	display: inline-block;
	content: "+";
	font: 12px monospace;
	border: 1px solid #458;
	line-height: 11px;
	height: 11px;
	width: 11px;
	text-align: center;
	border-radius: 50%;
	margin-right: 4px;
	vertical-align: middle;
	position: relative;
	top: -1px;
}
#doc .item.open > .header::before {
	content: "-";
}
#doc .item.empty > .header::before {
	content: " "; /*"Â·"*/
}
#doc .header:hover {
	border-left-color: #f3f3f3;
	background: #f3f3f3;
}
#doc .header .ret-arrow {
	font-weight: normal;
	margin: 0 0.1em;
}

#doc a.broken {
	color: red;
}
#doc p {
	margin: 0;
}
#doc p + p, #doc p.pad {
	margin-top: 0.5em;
}
#doc img {
	max-width: 100%;
}
#doc h3 {
	margin: 0.25em 0;
	font-size: 125%;
	font-weight: normal;
	border-bottom: 1px solid #ccc;
}

#doc .content, #doc ul {
	padding-left: 20px;
	border-left: 2px solid #f3f3f3;
}
#doc .content {
	padding-top: 0.25em;
	padding-bottom: 0.5em;
}
#doc tt {
	font-weight: bold;
}
#doc pre {
	font-family: Consolas, Dejavu Sans Mono, Segoe UI Mono, Ubuntu Mono, Lucida Console, monospace;
	font-size: 9pt;
	line-height: 1.25;
	background: white;
	padding: 4px 2px 4px 10px;
	margin: 0;
	tab-size: 4;
	overflow-x: auto;
	white-space: pre-wrap;
	word-break: break-all;
}
#doc pre a {
	text-decoration: none;
}
#doc pre a.uf {
	background-color: #f7f0ff;
}
#doc pre a.kw {
	background-color: #f0f7ff;
}
#doc pre a.sf, #doc pre a.sv {
	background-color: #fff3f0;
}
#doc pre a:hover {
	text-decoration: underline;
}
#doc abbr[title] {
	text-decoration: underline;
	text-decoration-color: #bbb;
	text-decoration-style: double;
}
#doc hr {
	margin: 0.5em 0;
	margin-right: 1em;
	border: 0;
	border-top: 2px dashed #f3f3f3;
}
#doc .item + hr {
	margin: 0;
	height: 1em;
	border: 1px solid #f3f3f3;
	border-width: 1px 0 1px 0;
}
#doc .item {
	border-top: 1px solid #f3f3f3;
	margin-top: 0.3em;
}
#doc .item:first-child {
	margin-top: 0em;
}
#doc .item:last-child {
	border-bottom: 1px solid #f3f3f3;
}
#doc .item + .item, #doc hr + .item {
	border-top: 0;
	margin-top: 0;
}
#doc .item + p {
	border-top: 1px solid #f3f3f3;
	padding-top: 0.3em;
}
/* delay display until load */
#doc[ready] .item:not(.open) > .content {
	display: none;
}
</style>
<style type="text/css" id="md_gml">
/* GameMakerLanguage */
pre.gmlmd .md { color: #7A81A9 } /* #define */
pre.gmlmd .kw { color: #008; font-weight: bold } /* keyword */
pre.gmlmd .co { color: #080 } /* comment */
pre.gmlmd .nu { color: #00f } /* number */
pre.gmlmd .nx { color: #00f } /* hex */
pre.gmlmd .st { color: #00f } /* string */
pre.gmlmd .ts { color: #00f } /* template string */
pre.gmlmd .op { color: #000 } /* operator */
pre.gmlmd .cb { color: #008; font-weight: bold } /* curly brace */
pre.gmlmd .sv { color: #800 } /* std func */
pre.gmlmd .sf { color: #800 } /* std var */
pre.gmlmd .ri { color: #0078aa } /* assets */
pre.gmlmd .uf { color: #808 } /* user func */
pre.gmlmd .uv { color: #000 } /* user var */
pre.gmlmd .lv { color: #648 } /* local var */
pre.gmlmd .fd { color: #804 } /* field */
</style>
<style type="text/css" id="night_css">
#night { display: none }
label[for="night"] {
	color: blue;
	text-decoration: underline;
	cursor: pointer;
}
#night:checked + .main {
	background-color: #405070;
}
#night:checked + .main .page {
	background-color: #1A202D;
	box-shadow: 0 0 0 2px #9bccff63;
	color: white;
}
#night:checked + .main a,
#night:checked + .main a:visited,
#night:checked + .main #doc .header,
#night:checked + .main label[for="night"] {
	color: #9DEC76;
}
#night:checked + .main #doc .header:before,
#night:checked + .main #doc h3 {
	border-color: #9DEC76
}
#night:checked + .main #doc .header,
#night:checked + .main #doc .header:hover,
#night:checked + .main #doc .content,
#night:checked + .main #doc .item,
#night:checked + .main #doc .item + p,
#night:checked + .main #doc hr,
#night:checked + .main #doc ul {
	border-color: rgba(205,225,255,0.1);
}
#night:checked + .main #doc .header:hover,
#night:checked + .main #doc .asset:hover {
	background: rgba(205,225,255,0.1);
}
#night:checked + .main div ul li {
	list-style-image: url('data:image/svg+xml;base256,<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="1em" viewBox="0 0 20px 1em"><circle cx="17px" cy="0.675em" r="2px" fill="white"/></svg>'); 
}
#night:checked + .main pre {
	color: #cccccc;
	background: #000000;
	border: 1px solid #3E4757;
}
#night:checked + .main pre.gmlmd .op { color: #CCCCCC }
#night:checked + .main pre.gmlmd .co { color: #5B995B }
#night:checked + .main pre.gmlmd .kw { color: #FFB871 }
#night:checked + .main pre.gmlmd .md { color: #FFB871 }
#night:checked + .main pre.gmlmd .cb { color: #FFB871 }
#night:checked + .main pre.gmlmd .sf { color: #FFB871 }
#night:checked + .main pre.gmlmd .uf { color: #FFB871 }
#night:checked + .main pre.gmlmd .nu { color: #FF8080 }
#night:checked + .main pre.gmlmd .st { color: #FCF320 }
#night:checked + .main pre.gmlmd .ts { color: #FF8080 }
#night:checked + .main pre.gmlmd .sv { color: #FF8080 }
#night:checked + .main pre.gmlmd .gv { color: #FF80FF }
#night:checked + .main pre.gmlmd .ri { color: #FF8080 }
#night:checked + .main pre.gmlmd .lv { color: #FFF899 }
#night:checked + .main pre.gmlmd .uv { color: #B2B1FF }
#night:checked + .main pre.gmlmd .fd { color: #B2B1FF }

#night:checked + .main pre.gmlmd a.uf {
	background-color: #431;
}
#night:checked + .main pre.gmlmd a.kw {
	background-color: #431;
}
#night:checked + .main pre.gmlmd a.sf,
#night:checked + .main pre.gmlmd a.sv {
	background-color: #431;
}
</style>
<style>
.main.boxtt #doc tt {
	display: inline-block;
	background: #FFFBE4;
	font-family: Consolas, Ubuntu Mono, Dejavu Sans Mono, Lucida Console, monospace;
	font-weight: normal;
	font-size: 12px;
	line-height: 16px;
	padding: 0 2px;
	border: 1px solid #E6E0C4;
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	max-width: 100%;
	word-break: break-word;
}
#night:checked + .main.boxtt #doc tt {
	background-color: #000;
	border-color: #5b7c9f;
	color: white;
}
</style>
<noscript><style>
#doc .header::before {
	display: none;
}
#doc .header:hover {
	border-left-color: #f3f3f3;
	background: inherit;
}
#doc { display: inherit }
#doc .item:not(.open) > .content {
	display: inherit;
}
</style></noscript>
</head><body>
<input type="checkbox" id="night" checked/>
<div class="main <!--%[mainclass]-->">
<script type="text/javascript">
(function() {
	var night = document.getElementById("night");
	var path = "docmd night mode";
	var ls = window.localStorage;
	if (ls) {
		night.checked = ls.getItem(path) == "true";
		night.onchange = function(_) {
			ls.setItem(path, "" + night.checked);
		};
	}
})();
</script>
<div class="page">
<p>This is a function "cheat sheet" for Steamworks.gml extension by YellowAfterlife.
The extension is available <a href="https://github.com/YellowAfterlife/steamworks.gml">on GitHub</a>.
Example files are available via <a href="https://yellowafterlife.itch.io/steamworks-gml-example">itch.io</a>.
Donations are accepted via itch.io.
A most up-to-date version of the manual is always <a href="https://yal.cc/r/17/steamworks-gml/">available online</a>.</p><p>
Click on sections to expand/collapse them.<br>Quick display controls: <a href="#" onclick="opt_none(); return false">Categories</a>
&middot; <a href="#" onclick="opt_list(); return false">Sections</a>
&middot; <a href="#" onclick="opt_all(); return false">Everything</a>
&middot; <label for="night">Toggle night mode</label><br/>
</p><div id="doc">
<!--<doc--><div class="item"><a class="header" id="General" href="#General" title="(permalink)">General</a><div class="content"><div class="item"><a class="header" id="setting-up-steam" href="#setting-up-steam" title="(permalink)">Setting up Steam</a><div class="content"><p>
		See the <a href="https://help.yoyogames.com/hc/en-us/articles/216754138-Using-The-Steamworks-SDK-With-GameMaker-Studio">official documentation.</a>
		</p><p>
		Additional note: you can use the test application ID (480) prior to being granted your own application ID, but generally it shouldn't be used for public builds.
	</p></div></div><div class="item"><a class="header" id="testing" href="#testing" title="(permalink)">Testing games with Steam networking</a><div class="content"><p>
		There are a few things to note about how Steam API works:
		</p><ul>
		<li>	If multiple instances of the same game are ran at once, Steam does not tell them apart, and will send events to whichever happens to ask for them first.
			</p><p>
			Steam client will generally try to prevent you from opening multiples of the same game, but it's possible when running from editor.
		</li><li>	Steam API uses user IDs as endpoints for connections, meaning that you cannot expect reliable results if trying to send something to yourself.
		</li></ul><p>
		That said, if you want to test two or more game instances on the same computer, you need to run them through multiple instances of Steam tied to multiple accounts.
		</p><p>
		Being a single-instance application, Steam will generally not let you open multiple copies of it at once, but that is easily fixed - by using software like <a href="https://en.wikipedia.org/wiki/Sandboxie">Sandboxie</a> (or equivalent), you can run multiple instances of Steam with separate accounts and game libraries (if needed).
		</p><p>
		To make the process even more straightforward, you can also run multiple game instances straight from the editor. To do so, you would add a small script to return the combined parameter string for the program,
		</p><pre class="gmlmd">
<span class="co">/// parameter_string_all()</span>
<span class="kw">var</span> <span class="lv">r</span> <span class="op">=</span> <span class="st">""</span><span class="op">;</span>
<span class="kw">var</span> <span class="lv">n</span> <span class="op">=</span> <span class="sf">parameter_count</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
<span class="kw">for</span> <span class="op">(</span><span class="kw">var</span> <span class="lv">i</span> <span class="op">=</span> <span class="nu">0</span><span class="op">;</span> <span class="lv">i</span> <span class="op">&lt;</span> <span class="lv">n</span><span class="op">;</span> <span class="lv">i</span><span class="op">++</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">if</span> <span class="op">(</span><span class="lv">i</span> <span class="op">&gt;</span> <span class="nu">0</span><span class="op">)</span> <span class="lv">r</span> <span class="op">+=</span> <span class="st">" "</span><span class="op">;</span>
    <span class="kw">var</span> <span class="lv">s</span> <span class="op">=</span> <span class="sf">parameter_string</span><span class="op">(</span><span class="lv">i</span><span class="op">)</span><span class="op">;</span>
    <span class="kw">if</span> <span class="op">(</span><span class="sf">string_pos</span><span class="op">(</span><span class="st">" "</span><span class="op">,</span> <span class="lv">s</span><span class="op">)</span><span class="op">)</span> <span class="cb">{</span>
        <span class="lv">r</span> <span class="op">+=</span> <span class="st">'"'</span> <span class="op">+</span> <span class="lv">s</span> <span class="op">+</span> <span class="st">'"'</span><span class="op">;</span>
    <span class="cb">}</span> <span class="kw">else</span> <span class="lv">r</span> <span class="op">+=</span> <span class="lv">s</span><span class="op">;</span>
<span class="cb">}</span>
<span class="kw">return</span> <span class="lv">r</span><span class="op">;</span>
</pre><p>and then copy that string to clipboard,
		</p><pre class="gmlmd">
<span class="sf">clipboard_set_text</span><span class="op">(</span><span class="uf">parameter_string_all</span><span class="op">(</span><span class="op">)</span><span class="op">)</span><span class="op">;</span>
</pre><p>on game start (or when other debug condition is met).
		</p><p>
		Then you would be able to use the copied parameter string to start up additional copies of the game in sandboxed environment(s).
	</p></div></div><div class="item"><a class="header" id="summary" href="#summary" title="(permalink)">Brief summary on Steam networking</a><div class="content"><p>
		There is a number of things to note about Steam networking compared to regular:
		</p><ul>
		<li>	System is P2P; user IDs are used as endpoints instead of IP+port.
			</p><p>
			If you need to port existing code utilizing IP+port combinations, you can use bit math to assume lower 32 bits to be the IP and higher 32 bits to be the port, for example.
		</li><li>	Steam handles sending/receiving and async events by itself, queuing the results.
			</p><p>
			This means that you generally should call the extension's update-function (<a href="#steam_net_update">steam_net_update</a>) every step while in lobby and at least once per second while not in lobby, or you may later deal with an avalanche of (outdated) events once finally calling it again.
			</p><p>
			This schema also introduces an interesting thing where if your game crashed without handling the remaining events/packets, you may receive them after restarting the game.
		</li><li>	Steam handles port forwarding by itself, meaning that it'll generally find any open port if there is one, and use a wide variety of workarounds to connect when there isn't one.
			</p><p>
			In worst case scenario Steam reverts to tunneling (using a Steam server as an intermediate node for connection), but this usually results in fairly high latency.
		</li><li>	Related to above, it may take up to 10 seconds to establish connection.
			</p><p>
			Afterwards, the connection is kept active for as long as anything is sent at least once every 30 seconds or so.
		</li></ul></div></div></div></div><div class="item"><a class="header" id="steam_general" href="#steam_general" title="(permalink)">General functions</a><div class="content"><div class="item"><a class="header" id="steam_net_check_version" href="#steam_net_check_version" title="(permalink)">steam_net_check_version()</a><div class="content"><p>
		Returns whether the native extension is loaded correctly and has it's version matching the one that the game had been built with.
		</p><p>
		Can be used to timely inform the player that their copy might be broken instead of having them wonder why things are not working.
		</p><pre class="gmlmd">
<span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="sf">steam_net_check_version</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">show_message</span><span class="op">(</span><span class="st">"oh no"</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span>
</pre></div></div><div class="item"><a class="header" id="steam_net_update" href="#steam_net_update" title="(permalink)">steam_net_update()</a><div class="content"><p>
		Polls Steam API and dispatches any new events since the last call to the function.
		</p><p>
		As outlined above, you generally want to call this function every now and then.
	</p></div></div><div class="item"><a class="header" id="steam_user_set_played_with" href="#steam_user_set_played_with" title="(permalink)">steam_user_set_played_with(user_id)</a><div class="content"><p>
		Adds the given user to the "recently played with" list (accessed via "Players" - "Recent games") menu in Steam overlay.
		</p><p>
		This is usually something to do on session start for all remote users.
	</p></div></div></div></div><div class="item"><a class="header" id="steam_async" href="#steam_async" title="(permalink)">Async events</a><div class="content"><p>
	As result of a number of function calls, the extension dispatches asynchronous events.
	</p><p>
	All of these events have <tt>async_load[?"success"]</tt> indicating whether the async action succeeded (true or false) and <tt>async_load[?"result"]</tt> containing the status code (descriptions can be found in Steam API documentation);
	</p><p>
	These can be caught by adding a Async - Steam event, and checking whether <tt>async_load[?"event_type"]</tt> is one of following names:
	</p><div class="item"><a class="header" id="lobby_list" href="#lobby_list" title="(permalink)">lobby_list</a><div class="content"><p>
		Triggers after requesting a list of public lobbies via <a href="#steam_lobby_list_request">steam_lobby_list_request</a>.
		</p><p>
		It is not required to do anything in response to this event.
		</p><p>
		<tt>async_load[?"lobby_count"]</tt> contains the number of matching lobbies (0 in case of network failure).
		</p><p>
		Use <a href="#steam_lobby_list">matchmaking functions</a> to retrieve other information.
	</p></div></div><div class="item"><a class="header" id="lobby_joined" href="#lobby_joined" title="(permalink)">lobby_joined</a><div class="content"><p>
		Triggers after requesting to join a lobby. This can fail if:
		</p><ul>
		<li>	There's no connection to Steam
		</li><li>	Lobby is full (no available player slots left)
		</li><li>	Lobby was destroyed before you requested to join it
		</li></ul><p>
		When successful, this is a good place to establish connection to lobby' members.
	</p></div></div><div class="item"><a class="header" id="lobby_created" href="#lobby_created" title="(permalink)">lobby_created</a><div class="content"><p>
		Fires after requesting to create a lobby. This can fail if:
		</p><ul>
		<li>	There's no connection to Steam
		</li><li>	You are trying to create a public lobby for a game that does not have matchmaking API enabled
		(is off by default for free games - request permissions via support forum).
		</li></ul><p>
		When successful, this is a good place to <a href="#steam_lobby_set_data">set up lobby data</a>.
	</p></div></div><div class="item"><a class="header" id="lobby_join_requested" href="#lobby_join_requested" title="(permalink)">lobby_join_requested</a><div class="content"><p>
		Triggers when the local player accepts an invitation via Steam overlay.
		</p><p>
		This event has several fields:
		</p><ul>
		<li>	<tt>async_load[?"lobby_id_high"]</tt>, <tt>async_load[?"lobby_id_low"]</tt> (combine via <a href="#steam_id_create">steam_id_create</a>) indicate the ID of the lobby to join (via <a href="#steam_lobby_join_id">steam_lobby_join_id</a>).
		</li><li>	<tt>async_load[?"friend_id_high"]</tt>, <tt>async_load[?"friend_id_low"]</tt> (combine via <a href="#steam_id_create">steam_id_create</a>) indicate the ID of the user that the invitation was from (in case you want to display "joining X's lobby" while loading).
		</li></ul><p>
		Is commonly used as following:
		</p><pre class="gmlmd">
<span class="kw">if</span> <span class="op">(</span><span class="sv">async_load</span><span class="op">[</span><span class="op">?</span><span class="st">"event_type"</span><span class="op">]</span> <span class="op">==</span> <span class="st">"lobby_join_requested"</span><span class="op">)</span> <span class="cb">{</span>
    <a class="sf" href="#steam_lobby_join_id">steam_lobby_join_id</a><span class="op">(</span><span class="uf">steam_id_create</span><span class="op">(</span>
        <span class="sv">async_load</span><span class="op">[</span><span class="op">?</span><span class="st">"lobby_id_high"</span><span class="op">]</span><span class="op">,</span>
        <span class="sv">async_load</span><span class="op">[</span><span class="op">?</span><span class="st">"lobby_id_low"</span><span class="op">]</span>
    <span class="op">)</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span>
</pre></div></div><div class="item"><a class="header" id="inventory_result_ready" href="#inventory_result_ready" title="(permalink)">inventory_result_ready</a><div class="content"><p>
		Fires after an inventory request finishes.
		</p><p>
		This is where you handle the returned value and call <a href="#steam_inventory_result_destroy">steam_inventory_result_destroy</a>.
		</p><p>
		Has the following fields: </p><ul>
		<li>	<tt>async_load[?"handle"]</tt>: <a href="#steam_inventory_result">steam_inventory_result</a>
		</li><li>	<tt>async_load[?"result"]</tt>: Status constant (see <a href="#steam_inventory_result_get_status">steam_inventory_result_get_status</a>).
		</li></ul><p class="pad">
		
		So, for example, you might do:
		</p><pre class="gmlmd">
<span class="kw">global</span><span class="op">.</span><span class="gv">fetch_items</span> <span class="op">=</span> <span class="uf">steam_inventory_item_retrieve_all</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
</pre><p>and then handle the result in the async event:
		</p><pre class="gmlmd">
<span class="kw">if</span> <span class="op">(</span><span class="sv">async_load</span><span class="op">[</span><span class="op">?</span><span class="st">"event_type"</span><span class="op">]</span> <span class="op">==</span> <span class="st">"inventory_result_ready"</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">var</span> <span class="lv">r</span> <span class="op">=</span> <span class="sv">async_load</span><span class="op">[</span><span class="op">?</span><span class="st">"handle"</span><span class="op">]</span><span class="op">;</span>
    <span class="kw">if</span> <span class="op">(</span><span class="lv">r</span> <span class="op">==</span> <span class="kw">global</span><span class="op">.</span><span class="gv">fetch_items</span><span class="op">)</span> <span class="cb">{</span>
        <span class="kw">var</span> <span class="lv">items</span> <span class="op">=</span> <span class="uf">steam_inventory_result_get_items</span><span class="op">(</span><span class="lv">r</span><span class="op">)</span><span class="op">;</span>
        <span class="co">// handle items here</span>
        <span class="uf">steam_inventory_result_destroy</span><span class="op">(</span><span class="lv">r</span><span class="op">)</span><span class="op">;</span>
    <span class="cb">}</span>
<span class="cb">}</span>
</pre></div></div><div class="item"><a class="header" id="steam_inventory_full_update" href="#steam_inventory_full_update" title="(permalink)">steam_inventory_full_update</a><div class="content"><p>
		Fires after <a href="#steam_inventory_item_retrieve_all">steam_inventory_item_retrieve_all</a> successfully returns a result which is newer/fresher than the last known result. A regular <a href="#inventory_result_ready">inventory_result_ready</a> event will trigger immediately afterwards.
		</p><p>
		Has the following fields: </p><ul>
		<li>	<tt>async_load[?"handle"]</tt>: <a href="#steam_inventory_result">steam_inventory_result</a>
		</li></ul><p class="pad">
		
		C++ version: <a href="https://partner.steamgames.com/doc/api/ISteamInventory#SteamInventoryFullUpdate_t">SteamInventoryFullUpdate_t</a>
	</p></div></div></div></div><div class="item"><a class="header" id="steam_net" href="#steam_net" title="(permalink)">Networking functions</a><div class="content"><p>
	The following functions allow to send and receive Steam P2P packets.
	</p><div class="item"><a class="header" id="steam_net_packet_receive" href="#steam_net_packet_receive" title="(permalink)">steam_net_packet_receive()</a><div class="content"><p>
		Attempts to get the next packet from Steam API and returns whether successfully done so.
		</p><p>
		Other <tt>steam_net_</tt> functions can then be used to get packet information/contents.
		</p><p>
		At most times you would utilize this as following:
		</p><pre class="gmlmd">
<span class="kw">while</span> <span class="op">(</span><span class="sf">steam_net_packet_receive</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="cb">{</span>
    <span class="co">// process the received packet</span>
<span class="cb">}</span>
</pre><p>(every step while in lobby, less frequently otherwise)
	</p></div></div><div class="item"><a class="header" id="steam_net_packet_get_sender_id" href="#steam_net_packet_get_sender_id" title="(permalink)">steam_net_packet_get_sender_id()</a><div class="content"><p>
		Returns Steam ID of the user that sent the last received packet.
		</p><p>
		Can be used in conjunction with <a href="#steam_net_packet_send">steam_net_packet_send</a> to send something back and for just telling the senders apart.
	</p></div></div><div class="item"><a class="header" id="steam_net_packet_get_size" href="#steam_net_packet_get_size" title="(permalink)">steam_net_packet_get_size()</a><div class="content"><p>
		Returns the size of last received packet, in bytes.
		</p><p>
		So, for instance, if you wanted to just display the size of each incoming packet, you could use a snippet of code like the following:
		</p><pre class="gmlmd">
<span class="kw">while</span> <span class="op">(</span><a class="sf" href="#steam_net_packet_receive">steam_net_packet_receive</a><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"Received "</span> <span class="op">+</span> <span class="sf">string</span><span class="op">(</span><span class="uf">steam_net_packet_size</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="st">" bytes."</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span>
</pre></div></div><div class="item"><a class="header" id="steam_net_packet_get_data" href="#steam_net_packet_get_data" title="(permalink)">steam_net_packet_get_data(buffer)</a><div class="content"><p>
		Copies the contents of last received packet to the given buffer.
		</p><p>
		Data is copied to the start of the buffer (position remains unaffected),
		meaning that if you reuse the same buffer, you should "rewind" it prior to reading.
		</p><p>
		If the buffer is not big enough to fit data, it will be resized automatically.
		</p><pre class="gmlmd">
<span class="kw">while</span> <span class="op">(</span><a class="sf" href="#steam_net_packet_receive">steam_net_packet_receive</a><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">steam_net_packet_get_data</span><span class="op">(</span><span class="uv">inbuf</span><span class="op">)</span><span class="op">;</span>
    <span class="sf">buffer_seek</span><span class="op">(</span><span class="uv">inbuf</span><span class="op">,</span> <span class="sv">buffer_seek_start</span><span class="op">,</span> <span class="nu">0</span><span class="op">)</span><span class="op">;</span>
    <span class="kw">switch</span> <span class="op">(</span><span class="sf">buffer_read</span><span class="op">(</span><span class="uv">inbuf</span><span class="op">,</span> <span class="sv">buffer_u8</span><span class="op">)</span><span class="op">)</span> <span class="cb">{</span>
        <span class="kw">case</span> <span class="nu">1</span><span class="op">:</span> <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"packet ID 1"</span><span class="op">)</span><span class="op">;</span> <span class="kw">break</span><span class="op">;</span>
        <span class="kw">case</span> <span class="nu">2</span><span class="op">:</span> <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"packet ID 2"</span><span class="op">)</span><span class="op">;</span> <span class="kw">break</span><span class="op">;</span>
        <span class="kw">default</span><span class="op">:</span> <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"unknown packet"</span><span class="op">)</span><span class="op">;</span> <span class="kw">break</span><span class="op">;</span>
    <span class="cb">}</span>
<span class="cb">}</span>
</pre><p>Whether <tt>inbuf</tt> is a "fixed" or "growing" buffer created on game start for the controller object.
	</p></div></div><div class="item"><a class="header" id="steam_net_packet_send" href="#steam_net_packet_send" title="(permalink)">steam_net_packet_send(steam_id, buffer, size, type)</a><div class="content"><p>
		Sends a packet to the given endpoint, returns whether successful (as opposed to incorrect arguments/invalid ID).
		</p><p>
		Much as with the built-in <tt>network_send_</tt> functions, this function takes data from the start of the buffer and until the point identified by <tt>size</tt> parameter.
		</p><p>
		<tt>type</tt> parameter can be one of the following:
		</p><ul>
		<li>	<tt>steam_net_packet_type_unreliable</tt>: roughly equivalent to UDP. May or may not be delivered, will not be resent automatically.
		</li><li>	<tt>steam_net_packet_type_unreliable_nodelay</tt>: much like the regular "unreliable" type, but always sent instantly (as soon as function is called). Intended for things like streaming voice data, where you want lowest latency possible and only care about the current data.
		</li><li>	<tt>steam_net_packet_type_reliable</tt>: roughly equivalent to TCP. Warranted to be delivered in order and intact.
		</li><li>	<tt>steam_net_packet_type_reliable_buffer</tt>: much like the regular "reliable" type, but utilizes <a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">Nagle's algorithm</a> to reduce the number of packets at cost of potential delay while the data accumulates until the sending threshold.
		</li></ul><p>
		So you could use it like so:
		</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">b</span> <span class="op">=</span> <span class="sf">buffer_create</span><span class="op">(</span><span class="nu">16</span><span class="op">,</span> <span class="sv">buffer_grow</span><span class="op">,</span> <span class="nu">1</span><span class="op">)</span><span class="op">;</span>
<span class="sf">buffer_write</span><span class="op">(</span><span class="lv">b</span><span class="op">,</span> <span class="sv">buffer_string</span><span class="op">,</span> <span class="st">"Hello!"</span><span class="op">)</span><span class="op">;</span>
<span class="sf">steam_net_packet_send</span><span class="op">(</span><span class="uv">steam_id</span><span class="op">,</span> <span class="lv">b</span><span class="op">,</span> <span class="sf">buffer_tell</span><span class="op">(</span><span class="lv">b</span><span class="op">)</span><span class="op">,</span> <span class="uv">steam_net_packet_type_reliable</span><span class="op">)</span><span class="op">;</span>
<span class="sf">buffer_delete</span><span class="op">(</span><span class="lv">b</span><span class="op">)</span><span class="op">;</span>
</pre><p>Where <tt>steam_id</tt> would hold the user ID to send the packet to.
	</p></div></div></div></div><div class="item"><a class="header" id="steam_lobby" href="#steam_lobby" title="(permalink)">Lobby functions</a><div class="content"><p>
	The following functions deal with the current lobby.
	</p><div class="item"><a class="header" id="steam_lobby_join_id" href="#steam_lobby_join_id" title="(permalink)">steam_lobby_join_id(lobby_id)</a><div class="content"><p>
		Starts joining a lobby with the given ID.
		</p><p>
		The operation is carried out asynchronously;
		</p><p>
		A <a href="#lobby_joined">lobby_joined</a> event is dispatched on completion.
		</p><p>
		See <a href="#lobby_join_requested">lobby_join_requested</a> for a code example.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_create" href="#steam_lobby_create" title="(permalink)">steam_lobby_create(type, max_members)</a><div class="content"><p>
		Starts creating a lobby.
		</p><p>
		The operation is carried out asynchronously;
		</p><p>
		A <a href="#lobby_created">lobby_created</a> event is dispatched on completion.
		</p><p>
		<tt>max_members</tt> indicates the maximum allowed number of users in the lobby
		(including the lobby' creator).
		</p><p>
		<tt>type</tt> can be one of the following:
		</p><ul>
		<li>	<tt>steam_lobby_type_private</tt>: Can only be joined by invitation.
			</p><p>
			You would usually <a href="#steam_lobby_set_type">change</a> the lobby type to this on match start.
		</li><li>	<tt>steam_lobby_type_friends_only</tt>: Can be joined by invitation or via friends-list
		(by opening the user' menu and picking "Join game").
		</li><li>	<tt>steam_lobby_type_public</tt>: Can be joined by invitation, via friends-list,
		and shows up in the public lobby list (see <a href="#steam_lobby_list">matchmaking</a> functions).
		</li></ul><p>
		Can be used as following:
		</p><pre class="gmlmd">
<span class="sf">steam_lobby_create</span><span class="op">(</span><span class="uv">steam_lobby_type_public</span><span class="op">,</span> <span class="nu">4</span><span class="op">)</span><span class="op">;</span>
</pre><p>(which would create a 4-player public lobby)
	</p></div></div><div class="item"><a class="header" id="steam_lobby_leave" href="#steam_lobby_leave" title="(permalink)">steam_lobby_leave()</a><div class="content"><p>
		Leaves the current lobby (if any).
		</p><p>
		Does not raise any errors if currently not in a lobby.
		</p><p>
		Note that if you are the lobby owner and leave the lobby, Steam transfers lobby ownership to any other available user, so you may need to detect lobby owner changes if any particular logic is handled by them.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_set_type" href="#steam_lobby_set_type" title="(permalink)">steam_lobby_set_type(newtype)</a><div class="content"><p>
		Changes the lobby' type. You must be the lobby' owner to do this.
		</p><p>
		Types are the same as per <a href="#steam_lobby_create">steam_lobby_create</a>.
		</p><p>
		So, for example, if you don't allow mid-session joining, you could have the game make lobbies private on session start:
		</p><pre class="gmlmd">
<span class="sf">steam_lobby_set_type</span><span class="op">(</span><span class="uv">steam_lobby_type_private</span><span class="op">)</span><span class="op">;</span>
</pre></div></div><div class="item"><a class="header" id="steam_lobby_get_data" href="#steam_lobby_get_data" title="(permalink)">steam_lobby_get_data(key:string)</a><div class="content"><p>
		Returns a lobby field value, as set by <a href="#steam_lobby_set_data">steam_lobby_set_data</a>.
		
</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">title</span> <span class="op">=</span> <span class="sf">steam_lobby_get_data</span><span class="op">(</span><span class="st">"title"</span><span class="op">)</span><span class="op">;</span>
</pre></div></div><div class="item"><a class="header" id="steam_lobby_set_data" href="#steam_lobby_set_data" title="(permalink)">steam_lobby_set_data(key:string, value:string)</a><div class="content"><p>
		Changes a lobby' field. You must be the lobby' owner to do this.
		</p><p>
		Fields can then be used to filter lobbies via <a href="#steam_lobby_list">matchmaking</a> functions.
		</p><p>
		<strong>Note</strong>: if your value is numeric, convert it to string prior to passing it to the function.
		</p><p>
		Otherwise GM will assume your numeric value to be a pointer to a string, which can hard crash your game and/or Steam client.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_is_owner" href="#steam_lobby_is_owner" title="(permalink)">steam_lobby_is_owner()</a><div class="content"><p>
		Returns whether the local player is the lobby' owner.
		</p><p>
		If the lobby is not valid, returns false.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_get_owner_id" href="#steam_lobby_get_owner_id" title="(permalink)">steam_lobby_get_owner_id()</a><div class="content"><p>
		Returns the lobby' owner' Steam ID.
		</p><p>
		If the lobby is not valid, returns ID 0.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_get_member_count" href="#steam_lobby_get_member_count" title="(permalink)">steam_lobby_get_member_count()</a><div class="content"><p>
		Returns the number of users in the current lobby (including you).
		</p><p>
		If the lobby is not valid, returns 0.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_get_member_id" href="#steam_lobby_get_member_id" title="(permalink)">steam_lobby_get_member_id(index)</a><div class="content"><p>
		Returns the user ID of the member at the given index in the current lobby.
		</p><p>
		Index should be between 0 (incl.) and result of <a href="#steam_lobby_get_member_count">steam_lobby_get_member_count</a> (excl.). Results will include the local user.
		</p><p>
		If the index (or lobby) is not valid, returns ID 0.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_activate_invite_overlay" href="#steam_lobby_activate_invite_overlay" title="(permalink)">steam_lobby_activate_invite_overlay()</a><div class="content"><p>
		Displays an invitation overlay if in lobby.
		</p><p>
		The invitation overlay is much akin to friends-list overlay, but only shows online friends, and spots "invite" buttons on each row.
	</p></div></div></div></div><div class="item"><a class="header" id="steam_lobby_list" href="#steam_lobby_list" title="(permalink)">Matchmaking functions</a><div class="content"><p>
	The following functions allow retrieving lists of public lobbies.
	</p><div class="item"><a class="header" id="steam_lobby_list_request" href="#steam_lobby_list_request" title="(permalink)">steam_lobby_list_request()</a><div class="content"><p>
		Starts loading the list of lobbies matching the current filters.
		</p><p>
		Filters are reset afterwards and have to be set again for subsequent request(s).
		</p><p>
		Existing results are kept up until the event is dispatched.
		</p><p>
		The operation is carried out asynchronously;
		</p><p>
		A <a href="#lobby_list">lobby_list</a> event is dispatched on completion.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_list_is_loading" href="#steam_lobby_list_is_loading" title="(permalink)">steam_lobby_list_is_loading()</a><div class="content"><p>
		Returns whether a lobby list request is currently underway.
		</p><p>
		Is a convenience function - you may as well set a global variable prior to calling <a href="#steam_lobby_list_request">steam_lobby_list_request</a> and reset in the <a href="#lobby_list">lobby_list</a> event.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_list_get_count" href="#steam_lobby_list_get_count" title="(permalink)">steam_lobby_list_get_count()</a><div class="content"><p>
		Returns the number of lobbies received in the last lobby list request.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_list_get_data" href="#steam_lobby_list_get_data" title="(permalink)">steam_lobby_list_get_data(index, key:string)</a><div class="content"><p>
		Returns the value of the given field of a lobby at the given index in the current list.
		</p><p>
		Fields can be set via <a href="#steam_lobby_set_data">steam_lobby_set_data</a>.
		</p><p>
		Index is between 0 (incl.) and <a href="#steam_lobby_list_get_count">steam_lobby_list_get_count()</a>' (excl.).
		</p><p>
		Value is always returned as a string.
		</p><p>
		Returns "" if the lobby does not have the given field set.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_list_get_lobby_id" href="#steam_lobby_list_get_lobby_id" title="(permalink)">steam_lobby_list_get_lobby_id(index)</a><div class="content"><p>
		Returns the Steam ID of the lobby at the given index in the list.
		</p><p>
		Index is between 0 (incl.) and <a href="#steam_lobby_list_get_count">steam_lobby_list_get_count()</a>' (excl.).
		</p><p>
		Returns ID 0 if the index is out of bounds.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_list_join" href="#steam_lobby_list_join" title="(permalink)">steam_lobby_list_join(index)</a><div class="content"><p>
		Starts joining the lobby at the given index in the list.
		</p><p>
		Index is between 0 (incl.) and <a href="#steam_lobby_list_get_count">steam_lobby_list_get_count()</a>' (excl.).
		</p><p>
		See <a href="#steam_lobby_join_id">steam_lobby_join_id</a> for more information on process.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_list_add_string_filter" href="#steam_lobby_list_add_string_filter" title="(permalink)">steam_lobby_list_add_string_filter(key, value, comparison_type)</a><div class="content"><p>
		Sets up a string filter for the next lobby list request.
		</p><p>
		That is, lobbies not matching the condition will be excluded from results.
		</p><p>
		Lobbies without the given field (<tt>key</tt>) will be assumed to have it as "".
		</p><p>
		The following values can be passed as <tt>comparison_type</tt>:
		</p><ul>
		<li>	<tt>steam_lobby_list_filter_eq</tt>: Equal (<tt>==</tt>).
		</li><li>	<tt>steam_lobby_list_filter_ne</tt>: Not-equal (<tt>!=</tt>).
		</li></ul></div></div><div class="item"><a class="header" id="steam_lobby_list_add_numerical_filter" href="#steam_lobby_list_add_numerical_filter" title="(permalink)">steam_lobby_list_add_numerical_filter(key, value, comparison_type)</a><div class="content"><p>
		Sets up a numeric filter for the next lobby list request.
		</p><p>
		That is, lobbies not matching the condition will be excluded from results.
		</p><p>
		Lobbies without the given field (<tt>key</tt>) will be excluded.
		</p><p>
		The following values can be passed as <tt>comparison_type</tt>:
		</p><ul>
		<li>	<tt>steam_lobby_list_filter_eq</tt>: Equal (<tt>==</tt>).
		</li><li>	<tt>steam_lobby_list_filter_ne</tt>: Not-equal (<tt>!=</tt>).
		</li><li>	<tt>steam_lobby_list_filter_lt</tt>: Less-than (<tt>&lt;</tt>).
		</li><li>	<tt>steam_lobby_list_filter_gt</tt>: Greater-than (<tt>&gt;</tt>).
		</li><li>	<tt>steam_lobby_list_filter_le</tt>: Less-than-or-equal (<tt>&lt;=</tt>).
		</li><li>	<tt>steam_lobby_list_filter_ge</tt>: Greater-than-or-equal (<tt>&gt;=</tt>).
		</li></ul></div></div><div class="item"><a class="header" id="steam_lobby_list_add_near_filter" href="#steam_lobby_list_add_near_filter" title="(permalink)">steam_lobby_list_add_near_filter(key, value:number)</a><div class="content"><p>
		Sorts the results based on how close their field' (<tt>key</tt>)' value is to the provided one.
		</p><p>
		If multiple near-filters are specified, the earlier-set ones take precedence.
	</p></div></div><div class="item"><a class="header" id="steam_lobby_list_add_distance_filter" href="#steam_lobby_list_add_distance_filter" title="(permalink)">steam_lobby_list_add_distance_filter(mode)</a><div class="content"><p>
		Restricts results by region and sorts them based on geographical proximity.
		</p><p>
		The following values can be passed as <tt>mode</tt>:
		</p><ul>
		<li>	<tt>steam_lobby_list_distance_filter_close</tt>: Only allows lobbies in same immediate region.
		</li><li>	<tt>steam_lobby_list_distance_filter_default</tt>: Allows lobbies in same or nearby regions (same continent)
		</li><li>	<tt>steam_lobby_list_distance_filter_far</tt>: Allows lobbies from up to half-way around the globe (nearby continents).
		</li><li>	<tt>steam_lobby_list_distance_filter_worldwide</tt>: Allows any lobbies. May result in very high latencies, so use with care.
		</li></ul></div></div></div></div><!--doc>-->
</div></div></div>
<script>(function() {
var doc, headers;
//
var path = "steamworks.gml cheat sheet";
var state = null;
if (window.localStorage && JSON.parse) {
	state = window.localStorage.getItem(path);
	state = state ? JSON.parse(state) : { };
	if (state == null) state = { };
}
var isLocal = (location.host.indexOf("localhost") == 0);
//
function h3bind(h3) {
	var node = h3.parentNode;
	var snip = node.children[1];
	var id = h3.id || h3.textContent;
	h3.snip = snip;
	h3.doc_set = function(z) {
		if (z) node.classList.add("open"); else node.classList.remove("open");
		if (state) {
			state[id] = z;
			window.localStorage.setItem(path, JSON.stringify(state));
		}
	}
	h3.doc_hide = function() {
		this.doc_set(false);
	}
	h3.doc_show = function() {
		this.doc_set(true);
	}
	h3.onclick = function(_) {
		var seen = !node.classList.contains("open");
		h3.doc_set(seen);
		return false;
	};
}
function getHashFunc(id) {
	var node = document.getElementById(id);
	if (node == null) return null;
	return function(e) {
		while (node && node != doc) {
			if (node.classList.contains("item")) {
				node.classList.add("open");
			}
			node = node.parentElement;
		}
	};
}
// Display helpers:
window.opt_none = function() {
	for (var li = 0; li < headers.length; li++) headers[li].doc_hide();
};
window.opt_list = function() {
	for (var li = 0; li < headers.length; li++) {
		var h3 = headers[li];
		if (h3.parentNode.parentNode != doc) {
			h3.doc_hide();
		} else h3.doc_show();
	}
};
window.opt_all = function() {
	for (var li = 0; li < headers.length; li++) headers[li].doc_show();
};
window.live_post = function() {
	doc = document.getElementById("doc");
	headers = doc.getElementsByClassName("header");
	//
	for (var i = 0; i < headers.length; i++) h3bind(headers[i]);
	// Clicks in document expand the related section:
	var anchors = doc.getElementsByTagName("a");
	for (var i = 0; i < anchors.length; i++) {
		var anchor = anchors[i];
		if (anchor.classList.contains("header")) continue;
		var href = anchor.getAttribute("href");
		if (href[0] == "#") {
			var fn = getHashFunc(href.substr(1));
			if (!fn) {
				anchor.classList.add("broken");
				anchor.title = "(section missing)";
			} else anchor.addEventListener("click", fn);
		}
	}
	//
	for (var li = 0; li < headers.length; li++) {
		var h3 = headers[li];
		var val = state ? state[h3.id || h3.textContent] : null;
		if (val == null) val = isLocal || h3.parentNode.parentNode == doc;
		if (val) h3.doc_show(); else h3.doc_hide();
	}
};
window.live_post();
//
(function() {
	var hash = document.location.hash;
	if (hash) {
		var _hash = hash.substr(1);
		getHashFunc(_hash)();
		setTimeout(function() {
			document.location.hash = hash + " ";
			setTimeout(function() {
				document.location.hash = hash;
			}, 100);
		}, 100);
	}
})();
//
doc.setAttribute("ready", "");
})();
</script>
</body></html>
